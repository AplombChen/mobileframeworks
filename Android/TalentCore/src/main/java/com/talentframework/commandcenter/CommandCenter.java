package com.talentframework.commandcenter;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import chat.utils.LogEx;

import com.talentframework.commandcenter.Command.OnCommandResultListener;
import com.talentframework.commandcenter.CommandResult.ResultType;
import com.talentframework.constants.TalentConstants;
import com.talentframework.reflection.CommandHolder;
import com.talentframework.reflection.ModuleHolder;
import com.talentframework.talentexception.TalentException;
import com.talentframework.utils.StringUtil;

public class CommandCenter {
	private static final String TAG = CommandCenter.class.getSimpleName();

	private static CommandCenter instance = new CommandCenter();

	private HashMap<String, ModuleHolder> modules;
	
	private List<CommandObserver> observers;
	
	private HashMap<String, InvocationHandler> interceptorMap;
	
	private CommandAfter after;
	private CommandBefore before;
	
	// TODO: 
//	private static ThreadPoolExecutor executorPool;
	
	private class FaultInvocationHandler implements InvocationHandler {
		@Override
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			return null;
		}
	}
	
	private CommandCenter() {
		observers = new ArrayList<CommandObserver>();
		try {
			init();
		} catch (TalentException e) {
			e.printStackTrace();
			LogEx.e(TAG, "CommandCenter init failed! " + e.getMessage());
		}
	}

	public static CommandCenter getInstance() {
		return instance;
	}

	private void init() throws TalentException {
		modules = new HashMap<String, ModuleHolder>();
		
		interceptorMap = new HashMap<String, InvocationHandler>();
		
//		executorPool = new ThreadPoolExecutor(2, 50, 60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());
		
		ModuleManager moduleMgr = ModuleManager.getInstance();
		moduleMgr.init();
		Class<?>[] moduleClasses = moduleMgr.getDeclaredModuleClasses();
		for(Class<?> clazz : moduleClasses){
			modules.put(StringUtil.getClassLastName(clazz), new ModuleHolder(clazz));
		}
	}

	/**
	 * Each command will have an id which generated by framework.
	 * 
	 * @param cmd
	 * @throws TalentException
	 */
	public void sendCommandAsync(final Command cmd) {
		new Thread(new Runnable() {
			@Override
			public void run() {
				executeCommandSync(cmd);
			}
		}).start();
	}

	public CommandResult executeCommandSync(Command cmd) {
 		Object result = null;
		CommandResult cmdResult = null;
		try {
			Object[] objects = cmd.getArguments();
			
			if (!Object[].class.equals(objects.getClass()))
				objects = new Object[] { objects };
			result = CommandCenter.instance.execute(cmd);
			cmdResult = new CommandResult();
			cmdResult.setCommand(cmd);
			cmdResult.setResultType(ResultType.Success);
			if (result != null) {
				cmdResult.setReturnObject(result);
			}
		} catch (IllegalArgumentException iae) {
			cmdResult = new CommandResult();
			cmdResult.setCommand(cmd);
			cmdResult.setResultType(ResultType.Failed);
			cmdResult.setException(new TalentException(
					TalentConstants.CC_COMMAND_ILLEGAL_PARAM.getCode(),
					"Illegal arguments for command " + cmd.getModuleName() + cmd.getMethod(), iae));
		} catch (IllegalAccessException iae) {
			cmdResult = new CommandResult();
			cmdResult.setCommand(cmd);
			cmdResult.setResultType(ResultType.Failed);
			cmdResult.setException(new TalentException(
					TalentConstants.CC_COMMAND_ILLEGAL_ACCESS.getCode(),
					"Illegal arguments for command " + cmd.getModuleName() + cmd.getMethod(), iae));
		} catch (InvocationTargetException ite) {
			cmdResult = new CommandResult();
			cmdResult.setCommand(cmd);
			cmdResult.setResultType(ResultType.Failed);
			
			if (ite.getTargetException() instanceof TalentException) {
				cmdResult.setException((TalentException) ite.getTargetException());
			} else {
				cmdResult.setException(new TalentException(
						TalentConstants.CC_COMMAND_EXCEPTION_OCCURED.getCode(), ite
						.getTargetException().getMessage()));
			}
		} catch (Throwable e) {
			e.printStackTrace();
			cmdResult = new CommandResult();
			cmdResult.setCommand(cmd);
			cmdResult.setResultType(ResultType.Failed);
			if (e instanceof TalentException){
				cmdResult.setException((TalentException) e);
			} else {
				cmdResult.setException(new TalentException(
					TalentConstants.CC_COMMAND_UNKNOWN_ERROR.getCode(),
					"Unexpected error " + e.getMessage() + " ;command=" + cmd.getModuleName() + cmd.getMethod(),
					e));
			}
		}
		List<OnCommandResultListener> cmdResults = cmd .getOnCommandResultListeners();
		if(cmdResults != null) {
			for (OnCommandResultListener listener : cmdResults) {
				try {
//				System.out.println("Command " + cmd.getCommandName() + " return the result " + cmdResult);
					listener.onCommandResult(cmdResult);
				} catch (Throwable t) {
					t.printStackTrace();
					LogEx.e(TAG, listener + " onCommandResult occured error : " + t.getMessage());
				}
			}
		}
		if(cmd.isEnableCommandAfter() && after != null) {
			try {
				CommandResult newResult = after.after(cmdResult);
				if(newResult != null)
					return newResult;
			} catch (Throwable t) {
				t.printStackTrace();
				LogEx.e(TAG, "after occured error : " + t.getMessage());
			}
		}
		return cmdResult;
	}

	public CommandResult executeCommandWithoutIntercept(Command cmd) {
		// TODO: executeCommandWithoutIntercept

		CommandResult cmdResult = new CommandResult();
		cmdResult.setCommand(cmd);

		try {
			ModuleHolder module = modules.get(cmd.getModuleName());
			Map<String, CommandHolder> cmdMap = module.getCommandMap();
			if (cmdMap.containsKey(cmd.getCommandName())) {
				CommandHolder cmdHolder = cmdMap.get(cmd.getCommandName());
				Object obj = ModuleManager.getInstance().newModule(module.getModuleClass());
				Object cmdobj;
				cmdResult.setResultType(ResultType.Success);

				cmdobj = (Object) cmdHolder.getMethod().invoke(obj, cmd.getArguments());
				if (cmdobj != null) {
					cmdResult.setReturnObject(cmdobj);
				}
			}

			return cmdResult;
		} catch (IllegalArgumentException e) {
			cmdResult.setResultType(ResultType.Failed);
			cmdResult.setException(new TalentException(
					TalentConstants.CC_COMMAND_ILLEGAL_PARAM.getCode(),
					"Illegal arguments for command " + cmd.getModuleName()
							+ cmd.getMethod(), e));
			return cmdResult;
		} catch (IllegalAccessException e) {
			cmdResult.setResultType(ResultType.Failed);
			cmdResult.setException(new TalentException(
					TalentConstants.CC_COMMAND_ILLEGAL_ACCESS.getCode(),
					"Illegal arguments for command " + cmd.getModuleName()
							+ cmd.getMethod(), e));
			return cmdResult;
		} catch (InvocationTargetException e) {
			cmdResult.setResultType(ResultType.Failed);

			if (e.getTargetException() instanceof TalentException) {
				cmdResult.setException((TalentException) e.getTargetException());
			} else {
				cmdResult.setException(new TalentException(
						TalentConstants.CC_COMMAND_EXCEPTION_OCCURED.getCode(),
						e.getTargetException().getMessage()));
			}
			return cmdResult;
		} catch (Throwable e) {
			cmdResult.setResultType(ResultType.Failed);
			if (e instanceof TalentException) {
				cmdResult.setException((TalentException) e);
			} else {
				cmdResult.setException(new TalentException(
						TalentConstants.CC_COMMAND_UNKNOWN_ERROR.getCode(),
						"Unexpected error " + e.getMessage() + " ;command="
								+ cmd.getModuleName() + cmd.getMethod(), e));
			}
			return cmdResult;
		}

	}

	private Object execute(Command cmd) throws Throwable {
		if (modules.containsKey(cmd.getModuleName())) {
			// observer onRequest
			LogEx.i(TAG, "Executing command " + cmd);
			CommandObserver[] cmdOb = null;
			synchronized (observers) {
				cmdOb = new CommandObserver[observers.size()];
				observers.toArray(cmdOb);
			}
			if (cmdOb != null) {
				for (CommandObserver observer : cmdOb) {
					observer.onRequest(cmd);
				}
			}
			
			String interceptorKey = getInterceptorKey(cmd);
//			System.out.println(" Print By lixq ---- The Interceptor Name Is : " + interceptorKey);
			
			Object interceptor = interceptorMap.get(interceptorKey);
			if (interceptor == null) {
				synchronized (interceptorMap) {
					Class<?> intercepterClass = null;
					try {
						intercepterClass = Class.forName(interceptorKey);
					} catch (Throwable t) {
//						t.printStackTrace();
					}
					if (intercepterClass != null && InvocationHandler.class.isAssignableFrom(intercepterClass)) {
						interceptor = intercepterClass.newInstance();
					} else {
						interceptor = new FaultInvocationHandler();
					}
					interceptorMap.put(interceptorKey, (InvocationHandler)interceptor);
				}
			}
			
			ModuleHolder module = modules.get(cmd.getModuleName());
			Map<String, CommandHolder> cmdMap = module.getCommandMap();
			if (cmdMap.containsKey(cmd.getCommandName())) {
				CommandHolder cmdHolder = cmdMap.get(cmd.getCommandName());
				Object obj = ModuleManager.getInstance().newModule(module.getModuleClass());
				Object cmdobj;
				
				if(cmd.isEnableCommandBefore() && before != null) {
					Object returnObj = before.before(cmd);
					if(returnObj != null)
						return returnObj;
				}
				
				//真正执行Command的地方
				if (cmd.isEnableInterceptor() && interceptor != null && !(interceptor instanceof FaultInvocationHandler)) {
					cmdobj = ((InvocationHandler)interceptor).invoke(obj, cmdHolder.getMethod(), cmd.getArguments());
					LogEx.i(TAG, "Intercepted command " + cmd + " result " + cmdobj);
				} else {
					cmdobj = (Object) cmdHolder.getMethod().invoke(obj, cmd.getArguments());
					LogEx.i(TAG, "Executed command " + cmd + " result " + cmdobj);
				}

				if (cmdOb != null) {
					for (CommandObserver observer : cmdOb) {
						observer.onResponse(cmd);
					}
				}
				return cmdobj;
			}
		}
		throw new TalentException(TalentConstants.CC_COMMAND_NOT_FOUND.getCode(), cmd.getCommandName() + " is NOT found!");
	}

	private void check() throws TalentException {
		if (modules == null) {
			throw new TalentException(TalentConstants.CC_COMMAND_HASNT_STARTUP.getCode(), "CommandCenter hasn't startup!");
		}
	}
	
	private String getInterceptorKey(Command command){
		StringBuffer interceptorSB = new StringBuffer(ModuleManager.getInstance().getPackageName());
		interceptorSB.append(".");
		interceptorSB.append(command.getModuleName());
		String methodStr = command.getMethod();
		interceptorSB.append(methodStr.replaceFirst(methodStr.substring(0, 1), methodStr.substring(0, 1).toUpperCase()));
		interceptorSB.append("Interceptor");
		
		return interceptorSB.toString();
	}
	
	/**
	 * @param args
	 */
	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

	public CommandAfter getAfter() {
		return after;
	}

	public void setAfter(CommandAfter after) {
		this.after = after;
	}

	public CommandBefore getBefore() {
		return before;
	}

	public void setBefore(CommandBefore before) {
		this.before = before;
	}

}
